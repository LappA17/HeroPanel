/* createSlice появилась для того что бы не разделять фционал actionCreator и Reducer 
   В результате ее работы мы получаем Объект который называют срезом или Slice
   Слайс помещают обычно в папку где к фционалу которого она привязана*/
import { createSlice } from "@reduxjs/toolkit";

/* createSlice принимает в себя 4 аргумента
1) name - пространство имен создаваемых действий(именно actionов)
2) initialState - начальное состояние reducer
3) reducers - Объект с обработчиками
4) extraReducers - Объект который содержит редьюсеры другого среза. Данный параметр может потребоваться в случае 
необходимости обновления Объекта, относящуемся к другому срезу. Допустим если бы мы что-то хотели поменять в фильтрах. 
И когда эта функция закончит свою работу - мы получим Объект с Тремя полями: имя среза, редьюсер и екшенс
    Фция createSlice объединяет всё что можно в данном фционале. Она и создает reducerы и генерирует екшенКрейторы
и так же она возвращает имя нашего Среза с которыми мы будем работать. По итогу нам не нужно будет разделять 
весь этот функциона на отдельные файлики и на отдельные сущности, всё будет в одном месте
    Но нужно помнить что это все равно всё тот же Редакс, просто обернутый в createSlice. У нас всё так же вызывается
фция Диспетч, с какими-то екшенами, они попадают в Редьюсер и Редьюсер уже меняет наш Стор */
const initialState = {
    heroes: [],
    heroesLoadingStatus: 'idle'
}

/* reducers - в множественном числе, внутри мы должны написать какие события будут внутри редьюсеров происходить
    heroesFetching: - здесь формируется екшенКрейтер
    state => {state.heroesLoadingStatus = 'loading'} - это действие которая работает на прямую со Стейтом
    immer так же работает в createSlice !!!  */
const heroesSlice = createSlice({
    name: 'heroes',
    initialState,
    reducers: {
        heroesFetching: state => {state.heroesLoadingStatus = 'loading'},
        heroesFetched: (state, action) => {
                    state.heroesLoadingStatus = 'idle';
                    state.heroes = action.payload;
                },
        heroesFetchingError: state => {
                    state.heroesLoadingStatus = 'error';
                },
        heroCreated: (state, action) => {
                    state.heroes.push(action.payload);
                },
        heroDeleted: (state, action) => {
                    state.heroes = state.heroes.filter(item => item.id !== action.payload);
                }
    }
})

/* Создаем Объект который у нас получается из heroesSlice. Диструктуризируем(вытаскиваем) actions и reducer */
const {actions, reducer} = heroesSlice

export default reducer

/* Все эти переменные будем получать из Объекта actions */
export const {
    heroesFetching,
    heroesFetched,
    heroesFetchingError,
    heroCreated,
    heroDeleted
} = actions

/* Подсумируем: 
В начале импортировали саму фцию
Дальше созадли начального состояния
Дальше запускаем эту фцию createSlice с созданием нашего нового Объекта heroesSlice. 
createSlice помещается 4 аргумента
Аргумент name - пространтсов имен, или как мы будем называть в общем наш Срез, в зависимости от этого названия
будут генерироваться различные сущности, по-этому нужно к нему относится серьезно. В том числе название 
нужно для того что бы внутри нашего стейта создавалось state.heroes

Дальше мы создаем отдельно екшенКрейторы к которым подвязываем действие по изменению стейта 
Если раньше мы создавали вот такую вот функцию export 
const heroesFetching = () => {
    return {
        type: 'HEROES_FETCHING'
    }
}
Которая возвращали Объект с определнным типом. 
Потом мы брали наш reducer и говорили что если такая строка у нас совпадает то 
case 'HEROES_FETCHING':
            return {
                ...state,
                heroesLoadingStatus: 'loading'
            }
То здесь мы все объеденили в одну строку heroesFetching: state => {state.heroesLoadingStatus = 'loading'} 

Переходим в наш Стор

ТЕПЕРЬ МОЖЕМ В actions УДАЛИТЬ ВСЁ ЧТО СВЯЗАННО С ГЕРОЯМИ*/
/* Так как мы создали heroesSlice то наш reducer heroes.js мы можем спокойно УДАЛИТЬ */

/* Так же мы можем создать какие-то данные
   Что бы это сделать нужно использовать специальную фукнцию
   Если нам нужно сгенерировать какой-то пейлоад, то что бы сгенерировать какой-то Екшен, то мы помещаем не 
фцию как мы это сделали вот здесь state.heroesLoadingStatus = 'loading', а мы помещаем Объект
    addToDo: {
        reducer: (state, action) => { Тут будет как раз вот эта фция , те то что нужно сделать со Стейтом
            state.push(action.payload)
        }, Когда будет запускаться reducer, то в наш Стейт пушим(добавляем) еще какой-то Объект.
        Но этот Объект еще нужно сформировать, по этому создаем второе свойсвто prepare
        prepare: (text) => { //text - это получаем какие-то данные
            const id = nanoid()
            return { payload: {id, text} }
        } И дальше эта фция генерирует просто Объект, со свойством payload, которое потом пойдет в reducer !!! 
        Там формируется id которое потом передается в reducer, а так же с каким-то text который был передан из-вне ! 
        Откуда из-вне ? Когда у нас используется фция heroDelete к примеру, она у нас диспетчиься и мы там ей в нашем
        случае передаем id - он пойдет в action.payload. Но если у нас есть фция prepare то она пойдем вот сюда (text)
        Он нам понадобиться на формирование payload, а потом он пойдет на пуш state.push(action.payload)
        ЭТО ЕСЛИ ВДРУГ НАМ ПОНАДОБИТЬСЯ ВРУЧНУЮ ГЕНЕРИРОВАТЬ ЭТО ЗНАЧЕНИЯ
    }
    */